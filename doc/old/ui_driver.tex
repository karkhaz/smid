\documentclass[11pt,a4paper]{article}

\input{colours-texified}
\input{macros.tex}

\begin{document}

\title{\il{uidriver} documentation}
\date{2015}
\author{Kareem Khazem}

\maketitle

\il{uidriver} is a tool that automatically interacts with interactive
programs, given a specification of what valid interactions with
that program look like.

A simple specification for a (fictional) word processor looks like
this:

\fsa{small}

which \il{uidriver} can visualise as this finite state automaton
(FSA):

\img{small}

Given this specification, \il{uidriver} sends keypresses to the word
processor by randomly following the arrows around the FSA, from the
initial state until the end state. Such a traversal represents a
`sensible' interaction with the word processor, similar to the actions
a real user would perform.

\il{uidriver} is:

\begin{itemize}

  \item automatic---it can be used to drive interactive programs
    without a user of the program being present.

  \item repeatable---the runs generated by \il{uidriver} can be
    recorded and `replayed', so that interesting program behaviours
    that are caused by certain sequences of user interactions can be
    replicated.

  \end{itemize}

\textbf{\large{Contents:}}

\section{Overview}

\section{The \il{fsa} language}

In this section, I present the language used to write program
specifications.

\subsection{Overview}

An \il{fsa} file is a list of \emph{commands}; the five types of
commands are

\begin{itemize}

  \item Comments
  \item Initial states
  \item Final states
  \item Transitions
  \item State hooks

\end{itemize}

Commands are separated by optional whitespace; they are not delimited
using \il{;} or any other such character. Line breaks are permitted
wherever whitespace is, to aid readability.

Identifiers must start with a letter or underscore and can contain
letters, underscores and digits.

Identifiers are used to name states. There is no notion of `declaring'
states before using them; therefore, if a state is misspelled
somewhere in the \il{fsa} file, then \il{uidriver} will interpret that
as being two different states.

\subsection{Comments}

Comments are script-style, i.e. they are started with a hash (\il{#})
and run until the end of the line. They are ignored by \il{uidriver}.

\begin{lstlisting}
# This is a comment...
\end{lstlisting}

\subsection{Initial and final states}

An initial state is indicated by writing the state name followed by an
outgoing arrow.

\fsa{initial}
\img{initial}

When \il{uidriver} is used to drive a program, it always starts
following arrows from an initial state.

A final state is indicated by writing the state name preceded by an
incoming arrow.

\fsa{final}
\img{final}

When \il{uidriver} is used to drive a program, it follows arrows
around until it reaches a final state, at which point it is assumed
that the program has been aborted.

\subsection{Transitions}

Transitions have many forms.

\subsubsection{Simple transitions}

The most straightforward one looks like this:

\fsa{simple_trans}
\img{simple_trans}

meaning that if we are on state \il{foo}, we can press \il{Ctrl+C} and
thereby end up on state \il{bar}. The \il{keys} directive in the
middle of the arrow is an \emph{action} and is described in section
\ref{sec:actions}.

\subsubsection{Source lists}

If the same key combination can be used to transition from several
different source states to some destination state, we can put all the
source states in a list:

\fsa{source_list}
\img{source_list}

This specifies that if we are on either \il{src1} or
\il{src2}, we can press \il{F1} and end up on \il{dest}.

\subsubsection{Transition from all states\label{sec:all}}

If we can press a certain key combination from \emph{all} states, we
can use the \il{all} keyword to avoid having to write out the list of
all states:

\fsa{all}
\img{all}

Note that \il{all} does not really mean \emph{all} states, for it
excludes final states (there is no transition going from \il{final} to
itself in this example). This is because final states cannot have
outgoing transitions; \il{uidriver} assumes that the target program
has aborted if it reaches a final state.

\subsubsection{Limiting the scope of all states}

If we want to use the \il{all} keyword to transition from all states
\emph{except for} a few states, we can list the excluded states after
the \il{all} symbol:

\fsa{all_except}
\img{all_except}

Here, we can press \il{Ctrl+Q} from any state except for the initial
state in order to quit the program.

\subsubsection{Staying on the same state\label{sec:stay}}

It is easy to write a simple transition which loops back on itself. In
this example, if we are on a web page, we can press the down-arrow key
to scroll down and we will still be on a web page:

\fsa{sour_stay}
\img{sour_stay}

\il{uidrive} does not actually produce diagrams like that by default
when it produces diagrams with \il{uidrive -d}.  This is because
having too many loops cause the diagram to become unreadable. When
\il{uidrive} sees the above \il{fsa} file, it will actually produce
the following
diagram:

\img{sour_stay_default}

If you like the first style (with explicit loops), you must invoke
\il{uidrive} as

\begin{lstlisting}
uidrive --loops -d <FSA_FILE>
\end{lstlisting}

If we want to specify that pressing a key will cause \emph{several
different states} to remain on the same state, we can use the
\il{stay} keyword.

\fsa{multi_stay}
\img{multi_stay}

\subsubsection{Actions\label{sec:actions}}

We have already encountered the \il{keys} action. In general, one can
specify one or more actions in the middle of a transition. When
\il{uidriver} is moving from one state to another, it performs the
actions in the transition.

The different actions one can use are:

\begin{description}

  \item[keys]{
    This keyword must be followed by a list of keys surrounded by
    brackets. It causes \il{uidriver} to send those keypresses to the
    target program with a small delay between each.
    \begin{lstlisting}
      keys [ a  b  Ctrl+5  \]  "  xf86VolumeUp ]
    \end{lstlisting}
  }

  \item[verb]{
    This keyword must be followed by a quoted string.  It causes
    \il{uidriver} to type the string verbatim into the program, as if
    a user were typing it on the keyboard.
    \begin{lstlisting}
      verb "This is some kind of string"
    \end{lstlisting}
  }

  \item[line]{
    This keyword must be followed by a quoted filename. It causes
    \il{uidriver} to read a single random line from the file, and
    types that line into the program. This is useful for storing e.g.
    a list of URLs separately from the \il{fsa} file, instead of
    having one \il{!verb} transition for each URL.
    \begin{lstlisting}
      line "./my_urls.txt"
    \end{lstlisting}
  }

  \item[TODO]{
      Various commands to move/click/manipulate the mouse cursor...
    }

\end{description}

There can be several actions in a single transition. Since linebreaks
are not significant in the language, it is recommended that
transitions with multiple actions are formatted nicely as follows:

\fsa{multi_action}
\img{multi_action}

This transition sends \il{Ctrl+F} to the program (to open a `find'
dialog), types in a random search term taken from a file, and then
sends the \il{Return} key to perform the search.

\subsection{State hooks\label{sec:state-hooks}}

By default, \il{uidriver} performs actions (see section
\ref{sec:actions}) whenever it takes a transition from state to state.
But we may sometimes want it to perform some other arbitrary commands
under certain circumstances, which are not related to interacting with
the program.

A \emph{state hook} is an arbitrary \il{bash} script that is executed
in response to a change of state. \emph{Pre-state hooks} run just
before transitioning to some state, and \emph{post-state hooks}
execute after leaving some state. They are specified using the
keywords \il{pre} or \il{post}, followed by a state, followed by a
bash script that is surrounded by curly braces.

\begin{lstlisting}
  post foo {
    echo "I'm leaving foo on" `date`
  }

  pre bar {
    ~/bin/entering_bar.sh
  }
\end{lstlisting}

A practical use for this is telling \il{uidriver} what window to send
keypresses to. By default, \il{uidriver} sends keypresses to the
window whose title matches the environment variable \il{WINDOW\_NAME},
but some programs open several windows with different titles.

\fsa{firefox}

This says that when we transition to the state \il{history\_window}
(corresponding to viewing the history window in Firefox), we should
change the \il{WINDOW\_NAME} variable so that keypresses are sent to
the right place. When we leave the history window, the
\il{WINDOW\_NAME} is reverted to its original value.

\subsection{Keywords}

These identifiers should not be used to name states.

\begin{itemize}

  \item \il{keys}, \il{verb}, \il{line}: see section
    \ref{sec:actions}.

  \item \il{all}: see section
    \ref{sec:all}.

  \item \il{pre}, \il{post}: see section
    \ref{sec:state-hooks}.

\end{itemize}

\section{Script generation}

\end{document}
